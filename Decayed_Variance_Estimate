import numpy as np
import pandas as pd

class Decayed_Point_Variance_Estimation:
    def __init__(self, s=1.0, memory=3):
        self.memory = memory
        self.s = s

    def point_naive_variance(self, data, day):
        # Correctly filter the data and select the last column
        D = data[data.iloc[:, -2] == day].iloc[:, -1]
        if D.empty:
            return np.nan  # Return NaN if the data is empty
        return np.var(D, ddof=1)  # Use ddof=1 for sample variance

    def point_variance(self, data, day, symmetric = True):
        # Correctly filter the data for the given range and select the last two columns
        if symmetric:
            D = data[data.iloc[:, -3].between(day - self.memory, day + self.memory+1)].iloc[:, -3:-1].values
        else:
            D = data[data.iloc[:, -3].between(day, day + self.memory+1)].iloc[:, -3:-1].values
        if len(D) == 0:
            return np.nan  # Return NaN if the data is empty
        U = np.unique(D[:, 0])
        V = np.zeros(len(U))
        for i in range(len(U)):
            V[i] = np.var(D[D[:, 0] == U[i], 1])
        W = np.exp(-((U - day) ** 2) / (2 * self.s **2))
        return np.average(V, weights=W)  # Compute weighted variance
    
    def variance(self, data, symmetric=True):
        days = np.unique(data.iloc[:, -3])  # Use unique days to avoid repetition
        output = {day: self.point_variance(data, day,symmetric=symmetric) for day in days}
        return output
